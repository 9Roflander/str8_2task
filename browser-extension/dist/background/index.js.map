{
  "version": 3,
  "sources": ["../../src/background/test-api.js", "../../src/background/index.js"],
  "sourcesContent": ["/**\n * Mock LLM API for testing message generation\n * This simulates what the real str8_2task app will provide\n */\n\nconst testMessages = {\n    acknowledgment: [\n        \"Thank you for sharing that insight.\",\n        \"That's a great point, I appreciate the clarification.\",\n        \"Understood, thanks for explaining.\",\n        \"I see what you mean, that makes sense.\",\n        \"Good to know, thank you!\"\n    ],\n    question: [\n        \"Could you elaborate on that point?\",\n        \"What are the next steps for this?\",\n        \"How does this align with our timeline?\",\n        \"Can you provide more details about the implementation?\",\n        \"What would be the best approach here?\"\n    ],\n    summary: [\n        \"To summarize: we'll proceed with the discussed approach.\",\n        \"Let me recap the key points from this discussion.\",\n        \"Just to confirm, we agreed on the following action items.\",\n        \"In summary, the main takeaways are...\",\n        \"To wrap up, here's what we've decided.\"\n    ]\n};\n\n/**\n * Generate a test LLM message\n * @param {string} type - Type of message: 'acknowledgment', 'question', or 'summary'\n * @returns {Promise<string>} Generated message\n */\nexport async function generateTestMessage(type = 'acknowledgment') {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 500));\n\n    const messages = testMessages[type] || testMessages.acknowledgment;\n    const randomIndex = Math.floor(Math.random() * messages.length);\n\n    return messages[randomIndex];\n}\n\n/**\n * This will be replaced with real API call to str8_2task app in Phase 2\n * @param {Object} context - Meeting context for LLM\n * @returns {Promise<string>} Generated message\n */\nexport async function generateLLMMessage(context) {\n    // TODO: In Phase 2, this will call the str8_2task app API\n    // For now, use test message generation\n    return generateTestMessage(context.type || 'acknowledgment');\n}\n", "import { generateTestMessage } from './test-api.js';\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\nconst BACKEND_WS_URL = 'ws://localhost:5167/ws/extension';\nconst RECONNECT_DELAY_MS = 5000;\nconst MAX_RECONNECT_ATTEMPTS = 10;\n\n// ============================================================================\n// WebSocket Connection Manager\n// ============================================================================\n\nclass WebSocketManager {\n    constructor(url) {\n        this.url = url;\n        this.ws = null;\n        this.connectionId = null;\n        this.reconnectAttempts = 0;\n        this.isConnecting = false;\n        this.shouldReconnect = true;\n    }\n\n    connect() {\n        if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) {\n            console.log('WebSocket already connected or connecting');\n            return;\n        }\n\n        this.isConnecting = true;\n        this.connectionId = `ext-${Date.now().toString(36)}-${Math.random().toString(36).substr(2, 5)}`;\n        \n        const wsUrl = `${this.url}?connection_id=${this.connectionId}`;\n        console.log(`Connecting to WebSocket: ${wsUrl}`);\n\n        try {\n            this.ws = new WebSocket(wsUrl);\n\n            this.ws.onopen = () => {\n                console.log('WebSocket connected to backend');\n                this.isConnecting = false;\n                this.reconnectAttempts = 0;\n                \n                // Send initial status\n                this.sendStatus();\n            };\n\n            this.ws.onmessage = (event) => {\n                this.handleMessage(event.data);\n            };\n\n            this.ws.onclose = (event) => {\n                console.log(`WebSocket closed: ${event.code} - ${event.reason}`);\n                this.isConnecting = false;\n                this.ws = null;\n                \n                if (this.shouldReconnect) {\n                    this.scheduleReconnect();\n                }\n            };\n\n            this.ws.onerror = (error) => {\n                console.error('WebSocket error:', error);\n                this.isConnecting = false;\n            };\n        } catch (error) {\n            console.error('Failed to create WebSocket:', error);\n            this.isConnecting = false;\n            this.scheduleReconnect();\n        }\n    }\n\n    scheduleReconnect() {\n        if (this.reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            console.warn('Max reconnection attempts reached, stopping');\n            return;\n        }\n\n        this.reconnectAttempts++;\n        const delay = RECONNECT_DELAY_MS * Math.min(this.reconnectAttempts, 5);\n        console.log(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${delay}ms`);\n\n        setTimeout(() => {\n            if (this.shouldReconnect) {\n                this.connect();\n            }\n        }, delay);\n    }\n\n    handleMessage(data) {\n        try {\n            const message = JSON.parse(data);\n            console.log('Received from backend:', message);\n\n            switch (message.action) {\n                case 'postMessage':\n                    this.handlePostMessage(message);\n                    break;\n                case 'ping':\n                    this.sendPong();\n                    break;\n                default:\n                    console.log('Unknown action:', message.action);\n            }\n        } catch (error) {\n            console.error('Failed to parse WebSocket message:', error);\n        }\n    }\n\n    async handlePostMessage(message) {\n        const { message: text, platform } = message;\n        \n        if (!text) {\n            console.error('No message text provided');\n            this.sendError('No message text provided');\n            return;\n        }\n\n        console.log(`Posting message to chat: \"${text.substring(0, 50)}...\"`);\n\n        try {\n            // Find a meeting tab\n            const tabs = await chrome.tabs.query({});\n            const meetingTab = tabs.find(tab => \n                tab.url && (\n                    tab.url.includes('meet.google.com') ||\n                    tab.url.includes('zoom.us') ||\n                    tab.url.includes('teams.microsoft.com') ||\n                    tab.url.includes('teams.live.com')\n                )\n            );\n\n            if (!meetingTab) {\n                console.error('No active meeting tab found');\n                this.sendError('No active meeting tab found');\n                return;\n            }\n\n            // Add to message queue\n            await messageQueue.add(text, platform || this.detectPlatform(meetingTab.url), meetingTab.id);\n            \n            // Confirm message was queued\n            this.send({\n                action: 'message_sent',\n                message_id: Date.now().toString(),\n                success: true\n            });\n        } catch (error) {\n            console.error('Failed to post message:', error);\n            this.sendError(error.message);\n        }\n    }\n\n    detectPlatform(url) {\n        if (url.includes('meet.google.com')) return 'google-meet';\n        if (url.includes('zoom.us')) return 'zoom';\n        if (url.includes('teams.microsoft.com') || url.includes('teams.live.com')) return 'microsoft-teams';\n        return null;\n    }\n\n    send(data) {\n        if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n            this.ws.send(JSON.stringify(data));\n        } else {\n            console.warn('WebSocket not connected, cannot send:', data);\n        }\n    }\n\n    sendPong() {\n        this.send({ action: 'pong' });\n    }\n\n    sendError(error) {\n        this.send({ action: 'error', error });\n    }\n\n    async sendStatus() {\n        // Check for active meeting tabs\n        const tabs = await chrome.tabs.query({});\n        const meetingTab = tabs.find(tab => \n            tab.url && (\n                tab.url.includes('meet.google.com') ||\n                tab.url.includes('zoom.us') ||\n                tab.url.includes('teams.microsoft.com') ||\n                tab.url.includes('teams.live.com')\n            )\n        );\n\n        this.send({\n            action: 'status',\n            platform: meetingTab ? this.detectPlatform(meetingTab.url) : null,\n            meeting_active: !!meetingTab,\n            queue_length: messageQueue.getStatus().queueLength\n        });\n    }\n\n    disconnect() {\n        this.shouldReconnect = false;\n        if (this.ws) {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n\n    getStatus() {\n        return {\n            connected: this.ws && this.ws.readyState === WebSocket.OPEN,\n            connectionId: this.connectionId,\n            reconnectAttempts: this.reconnectAttempts\n        };\n    }\n}\n\n// ============================================================================\n// Message Queue (existing implementation)\n// ============================================================================\n\nclass MessageQueue {\n    constructor() {\n        this.queue = [];\n        this.processing = false;\n    }\n\n    async add(message, platform, tabId) {\n        this.queue.push({ message, platform, tabId, timestamp: Date.now() });\n        console.log(`Added message to queue. Queue length: ${this.queue.length}`);\n\n        if (!this.processing) {\n            await this.process();\n        }\n    }\n\n    async process() {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const item = this.queue.shift();\n            console.log(`Processing message from queue. Remaining: ${this.queue.length}`);\n\n            try {\n                await this.sendMessage(item);\n                // Wait between messages to avoid overwhelming the platform\n                await new Promise(resolve => setTimeout(resolve, 1000));\n            } catch (error) {\n                console.error('Failed to send message:', error);\n                // Retry logic: add back to queue if failed (max 3 retries)\n                if (!item.retries || item.retries < 3) {\n                    item.retries = (item.retries || 0) + 1;\n                    console.log(`Retrying message (attempt ${item.retries}/3)`);\n                    this.queue.push(item);\n                    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait before retry\n                }\n            }\n        }\n\n        this.processing = false;\n    }\n\n    async sendMessage({ message, platform, tabId }) {\n        return new Promise((resolve, reject) => {\n            chrome.tabs.sendMessage(\n                tabId,\n                {\n                    action: 'postMessage',\n                    message: message,\n                    platform: platform\n                },\n                (response) => {\n                    if (chrome.runtime.lastError) {\n                        reject(new Error(chrome.runtime.lastError.message));\n                    } else if (response && response.success) {\n                        console.log('Message posted successfully');\n                        resolve(response);\n                    } else {\n                        reject(new Error(response?.error || 'Unknown error'));\n                    }\n                }\n            );\n        });\n    }\n\n    getStatus() {\n        return {\n            queueLength: this.queue.length,\n            processing: this.processing\n        };\n    }\n}\n\n// ============================================================================\n// Initialize Instances\n// ============================================================================\n\nconst messageQueue = new MessageQueue();\nconst wsManager = new WebSocketManager(BACKEND_WS_URL);\n\n// ============================================================================\n// Extension Lifecycle\n// ============================================================================\n\n// Extension installation handler\nchrome.runtime.onInstalled.addListener((details) => {\n    console.log('str8_2task extension installed:', details.reason);\n\n    if (details.reason === 'install') {\n        chrome.storage.local.set({\n            installed: true,\n            version: chrome.runtime.getManifest().version\n        });\n    }\n    \n    // Connect to backend WebSocket\n    wsManager.connect();\n});\n\n// Service worker startup - connect to WebSocket\nwsManager.connect();\n\n// ============================================================================\n// Message Handlers\n// ============================================================================\n\n// Handle messages from popup and content scripts\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    console.log('Background received message:', request);\n\n    if (request.action === 'postMessage') {\n        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n            if (tabs[0]) {\n                messageQueue.add(request.message, request.platform, tabs[0].id)\n                    .then(() => sendResponse({ success: true }))\n                    .catch((error) => sendResponse({ success: false, error: error.message }));\n            } else {\n                sendResponse({ success: false, error: 'No active tab found' });\n            }\n        });\n        return true; // Keep message channel open for async response\n    }\n\n    if (request.action === 'generateTestMessage') {\n        generateTestMessage(request.messageType)\n            .then((message) => {\n                sendResponse({ success: true, message });\n            })\n            .catch((error) => {\n                sendResponse({ success: false, error: error.message });\n            });\n        return true;\n    }\n\n    if (request.action === 'getQueueStatus') {\n        sendResponse({\n            ...messageQueue.getStatus(),\n            websocket: wsManager.getStatus()\n        });\n        return true;\n    }\n    \n    if (request.action === 'getWebSocketStatus') {\n        sendResponse(wsManager.getStatus());\n        return true;\n    }\n    \n    if (request.action === 'reconnectWebSocket') {\n        wsManager.shouldReconnect = true;\n        wsManager.reconnectAttempts = 0;\n        wsManager.connect();\n        sendResponse({ success: true });\n        return true;\n    }\n});\n\n// Handle external messages from str8_2task app (Phase 2)\nchrome.runtime.onMessageExternal.addListener((request, sender, sendResponse) => {\n    console.log('Background received external message from:', sender.url);\n    console.log('Request:', request);\n\n    if (request.action === 'postMessage') {\n        // Find the meeting tab\n        chrome.tabs.query({}, (tabs) => {\n            const meetingTab = tabs.find(tab =>\n                tab.url.includes('meet.google.com') ||\n                tab.url.includes('zoom.us') ||\n                tab.url.includes('teams.microsoft.com') ||\n                tab.url.includes('teams.live.com')\n            );\n\n            if (meetingTab) {\n                messageQueue.add(request.message, request.platform, meetingTab.id)\n                    .then(() => sendResponse({ success: true }))\n                    .catch((error) => sendResponse({ success: false, error: error.message }));\n            } else {\n                sendResponse({\n                    success: false,\n                    error: 'No active meeting tab found'\n                });\n            }\n        });\n        return true;\n    }\n\n    if (request.action === 'ping') {\n        sendResponse({ \n            success: true, \n            message: 'Extension is active',\n            websocket: wsManager.getStatus()\n        });\n        return true;\n    }\n});\n\n// Extension icon click handler (optional)\nchrome.action.onClicked.addListener((tab) => {\n    // Could open popup or perform action\n});\n\n// Periodically send status updates to backend\nsetInterval(() => {\n    if (wsManager.ws && wsManager.ws.readyState === WebSocket.OPEN) {\n        wsManager.sendStatus();\n    }\n}, 30000); // Every 30 seconds\n\nconsole.log('str8_2task background service worker initialized');\n"],
  "mappings": "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",
  "names": []
}
